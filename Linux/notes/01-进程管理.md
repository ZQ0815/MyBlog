# 进程管理

## 查看进程
### 1. ps
查看某个时间点的进程信息。

示例：查看自己的进程
`# ps -l`
示例：查看系统所有进程
`# ps aux`
示例：查看特定的进程
`# ps aux | grep threadx`
### 2. pstree
查看进程树。

示例：查看所有进程树
`# pstree -A`

### 3. top
实时显示进程信息。

示例：两秒钟刷新一次
`# top -d 2`

### 4. netstat
查看占用端口的进程

示例：查看特定端口的进程
`# netstat -anp | grep port`

## 进程状态

| 状态 | 说明 |
| :---: | --- |
| R | running or runnable (on run queue)<br>正在执行或者可执行，此时进程位于执行队列中。|
| D | uninterruptible sleep (usually I/O)<br>不可中断阻塞，通常为 IO 阻塞。 |
| S | interruptible sleep (waiting for an event to complete) <br> 可中断阻塞，此时进程正在等待某个事件完成。|
| Z | zombie (terminated but not reaped by its parent)<br>僵死，进程已经终止但是尚未被其父进程获取信息。|
| T | stopped (either by a job control signal or because it is being traced) <br> 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。|
<br>

## SIGCHLD

当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：

- 得到 SIGCHLD 信号；
- waitpid() 或者 wait() 调用会返回。

其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。

在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。

## wait()

```c
pid_t wait(int *status)
```

父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。

如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。

参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。

## waitpid()

```c
pid_t waitpid(pid_t pid, int *status, int options)
```

作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。

pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。

options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。

## 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

## 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

## 守护进程
守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。

守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。

- 守护进程是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或循环等待处理某些事件的发生；
- 守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机才随之一起停止运行；
- 守护进程一般都以root用户权限运行，因为要使用某些特殊的端口或者资源；
- 守护进程的父进程一般都是init进程，因为它真正的父进程在fork出守护进程后就直接退出了，所以守护进程都是孤儿进程，由init接管；

## 进程间的通讯方式
管道、命名管道、内存映射、消息队列、共享内存、信号量、信号、套接字。

**1、管道 PIPE**：特指无名管道，是一种半双工的通讯方式，数据只能单向流动。只能用于**父子进程**之间的通讯。一个管道有两个端口，一个读口，一个写口。
管道实际上是内核的一个缓冲区，在内存中。缓冲区不需要很大，它被设计为环形的。当缓冲区满了，写进程会等待。当两个进程都结束时，管道会自动消失。

**2、命名管道 FIFO**：是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了管道的弊端，他可以**允许没有亲缘关系的进程间通信**。在命名管道中，管道可以是事先已经创建好的。（匿名对象）

**3、共享内存：**共享内存是在多个进程之间共享内存区域的一种进程间的通信方式。由**IPC**(进程间通信) 为进程创建的一个特殊地址范围。共享内存本身并没有同步机制，需要程序员自己控制。共享内存是IPC最快捷的方式，因为共享内存方式的通信没有中间过程。

**4、信号：**信号机制是 Unix 系统中最为古老的进程之间的通信机制，用于一个或几个进程之间传递异步信号。信号可以由各种异步事件产生，比如键盘中断等。shell也可以使用信号将作业控制命令传递给它的子进程。
信号是在软件层次上对**中断机制的一种模拟**。信号是异步的。信号事件发生的来源有两个：硬件来源和软件来源。
信号的分类：可靠信号, 不可靠信号；实时信号, 非实时信号。
进程对信号的响应：1、忽略信号；2、捕捉信号；执行默认操作。
信号的生命周期：信号诞生、信号在进程中注册、信号在进程中注销、信号处理函数执行。

**5、消息队列：**消息队列是内核地址空间中的**内部链表**，通过 Linux 内核在各个进程直接传递内容，消息顺序地发送到消息队列中。不同的消息队列直接是相互独立的。（类比线程池）

与命名管道相比，消息队列的优势在于：
1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。（类比 UDP TCP）
2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。
3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。

**6、信号量：**主要作为进程间以及同一进程不同线程之间的**同步**手段。

**7、套接字：**更为一般的进程间通信机制，可用于**不同机器**之间的进程间通信。

