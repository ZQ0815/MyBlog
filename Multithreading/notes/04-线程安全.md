# 线程安全
当多个线程访问一个对象时，如果不考虑这些线程在执行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。
## Java线程安全
>按照安全程度由强到弱分为五个类别
### 不可变
在Java语言中不可变的对象一定是线程安全的，无论是对象的方法实现还是方的调用者，都不需要再采用任何的线程安全保障措施。如final关键字，只要一个不可变对象被正确构建出来（没有发生this引用逃逸，即对象还未构造完成this引用就被发布出去了），那其外部的可见状态永远不会发生改变，永远不会看到它在多个线程之中处于不一致的状态。

### 绝对线程安全
不管运行时环境如何，调用者都不需要任何额外的同步措施。
- 如java.util.Vector是一个线程安全的容器，它的get,add,size等方法都是被synchronized修饰的，效率很低 ，但确实是安全的。但并不意味着调用时永远不需要同步手段，如多线程中一个线程在错误的时间里对元素进行了删除，就会导致边界异常。此时对删除需要进入同步块处理。（用synchronized(vector)框住代码块）

### 相对线程安全
相对的线程安全就是我们通常意义上所讲的线程安全。
要保证对这个对象单独的操作是线程安全的，调用时不需要做额外的保障措施，但对一些特定的顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。
Java中大部分都属于这类，如Vector,HashTable，Collections的synchronizedCollection()方法包装的集合等。

### 线程兼容
线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。

### 线程对立
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。

# 线程安全的实现方法
## 互斥同步（阻塞同步）
互斥同步是常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程使用。

### 实现手段
- synchronized关键字

synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象

- ReentrantLock重入锁

ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁（lock（）和unlock（）方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。不过，相比synchronized,ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件
1. 等待可中断

等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等
待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。

2. 可实现公平锁

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；

3. 锁可以绑定多个条件

锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition（）方法即可。

## 非阻塞同步
### 阻塞同步的缺点
互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

### 乐观锁和悲观锁

- 悲观锁：总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁
- 乐观锁：先进行操作，如果没有其他线程争用资源就成功；如果有就进行其他补偿措施。

### CAS指令
CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

- ABA问题：如果一个V初次读取的时候是A，且在准备赋值的时候还是A，我们能说它的值没有被其他线程改变过么？如果在这期间曾改为B，又改回A，那CAS就会误认为它从来没有被改变过。这个漏洞就是CAS操作的ABA问题。

### 线程本地存储
如果一段代码中所需要的数据必须与其他代码共享，那就**看看这些共享数据的代码是否能保证在同一个线程中执行？**如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

>深入了解ThreadLocal类，看看源码。